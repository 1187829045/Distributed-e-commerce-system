## 第一天

### 1.安装环境

### 2.rpc :

rpc 叫做远程过程调用，一个节点请求另一个节点提供的服务
对应rpc的是本地过程调用，函数调用是最常见的本地过程调用
将本地过程调用变成远程过程调用会面临各种问题

rpc 技术在架构设计上由四部分 客户端，客户端存根，服务端，服务端存根

## 第二天

安装学习了grpc

### GRPC（gRPC Remote Procedure Call）
是一个高性能、通用的开源远程过程调用（RPC）框架，由Google开发。
它基于HTTP/2协议和Protocol Buffers（protobuf）数据序列化格式，旨在简化跨网络的函数调用，
使得不同系统之间的通信更高效、更可靠。gRPC适用于构建分布式系统和微服务架构中的服务间通信。
服务端的数据流模式：这种模式是客户端发起一次请求，服务端返回一段连续的数据流。
客户端数据来模式：与上面相反，客户端源源不断向服务端发送数据流
双向数据流模式：上面综合，比如聊天软件

### 学习protobuf grpc

## 第三天
### 拦截器
在 gRPC 中，拦截器（interceptor）是一种中间件机制，可以在 gRPC 方法调用之前或之后执行一些通用的逻辑。

       interceptor := func(ctx context.Context, req interface{},
       info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
       fmt.Println("接受到一新的请求")
       return handler(ctx, req)
     }

ctx 是一个上下文对象，它携带了请求的范围和生命周期信息 ，req 是请求参数，表示传递给 gRPC 方法的具体请求消息
，info 提供了关于当前调用的一些信息，例如被调用的方法的全名等。
，handler 是实际处理请求的函数，当拦截器完成它的工作之后，可以调用这个函数来继续处理请求。
，拦截器在 gRPC 中扮演着类似于中间件的角色，允许在 gRPC 方法调用之前或之后插入自定义逻辑。这对于实现许多通用功能非常有用

grpc 通过metadata传输密码，放在拦截器中，可以形成验证的中间件方式

### 验证器生成命令

protoc -I. --go_out=. helloworld.proto
protoc -I. --go-grpc_out=. helloworld.proto
protoc -I. --validate_out="lang=go:." helloworld.proto

grpc客户端与服务端流程

### 服务端

            // 创建一个新的 gRPC 服务器实例
             g := grpc.NewServer()
           // 注册 Greeter 服务到 gRPC 服务器
           // 将 Server 的实例传递给生成的 RegisterGreeterServer 方法
           pb.RegisterGreeterServer(g, &Server{})
            // 监听所有网络接口上的 8080 端口
           lis, err := net.Listen("tcp", "0.0.0.0:8080")
           // 启动 gRPC 服务器以监听传入的连接
           // 如果服务器运行过程中出现错误，记录错误并退出程序
           if err := g.Serve(lis); err != nil {
           log.Fatalf("failed to serve: %v", err)
            }     

### 客户端

            // 创建一个与 gRPC 服务器的连接
            conn, err := grpc.Dial("127.0.0.1:8080", grpc.WithInsecure()) // 改为 8080 端口
            // 延迟关闭连接，确保程序结束前连接会被关闭
            defer conn.Close()
            // 创建一个新的 Greeter 客户端实例
             c := proto.NewGreeterClient(conn)
           // 调用 服务端定义的方法
            r, err := c.SayHello(context.Background(), &proto.HelloRequest{Name: "bobby"})
## 第六周
### 单体应用

单体应用是一种传统的软件架构模式，它是指将整个应用程序作为一个单一的、 完整的单元来开发、部署和维护。
在单体应用中， 所有的功能模块、业务逻辑以及数据访问都被打包在一起，并部署到同一个运行环境中。
可扩展性差：随着应用规模的增长，单体应用的可扩展性会变差。由于所有的组件都耦合在一起，很难对某个特定组件进行水平扩展。
难以维护：随着时间的推移，单体应用往往会变得越来越庞大、复杂，导致代码难以理解和维护。
技术栈固定：由于整个应用都使用同一种技术栈，因此很难引入新的技术或更新现有技术。

### 微服务应用
微服务应用是一种分布式系统架构模式，它将应用程序拆分成多个小型服务，每个服务都有自己独立的业务功能，
并通过轻量级的通信机制来相互协作。 每个微服务都可以独立部署、扩展和维护，从而提高了系统的灵活性、可扩展性和可维护性。
前后端分离系统开发接口管理痛点

# 第四天
### yapi
Yapi 是一个可视化的接口管理工具，主要用于接口的管理、文档的生成和测试的执行.
它提供了一个用户友好的界面，让开发团队能够更轻松地管理接口，生成接口文档，并进行接口测试。
Yapi 的一些主要功能和作用：
接口管理： Yapi 提供了一个可视化的界面，让用户能够方便地创建、编辑和删除接口，管理接口的请求和响应参数，设置接口的状态和分类等。
接口文档生成： Yapi 能够自动根据接口的定义生成接口文档，包括接口的描述、请求参数、响应参数等信息，使团队成员能够更清晰地了解接口的使用方法和规范。
接口测试： Yapi 允许用户在界面中直接进行接口测试，通过输入参数和发送请求来测试接口的功能和性能，并查看测试结果和日志。
权限管理： Yapi 支持多用户协作，管理员可以根据需要设置不同用户的权限，控制其对接口的访问、编辑和管理权限。
团队协作： Yapi 提供了团队协作的功能，允许多个团队成员共同使用和管理接口，提高团队的协作效率和开发质量。

### orm
ORM（Object-Relational Mapping）是一种编程技术，用于将面向对象的程序中的对象与关系型数据库中的表之间建立映射关系，
从而实现对象和数据库之间的数据转换和交互。
在传统的关系型数据库中，数据是以表的形式存储的，每个表包含多个列，每行代表一个记录。而在面向对象编程中，数据以对象的形式表示，每个对象包含多个属性。
ORM 技术的目标是解决关系型数据库和面向对象编程之间的差异，让开发者可以使用面向对象的方式来操作数据库，而不必直接编写 SQL 语句。

#### ORM 主要有以下几个核心概念：

对象（Object）： 在面向对象编程中表示一个实体或数据模型的抽象，通常由类或结构体表示
关系型数据库表（Relational Database Table）： 数据库中的数据以表的形式组织，每个表包含多个行和列，每行代表一个记录，每列代表一个属性。
映射（Mapping）： 将对象的属性映射到数据库表的列，使得对象和数据库表之间可以相互转换和交互。
持久化（Persistence）： 将对象的状态持久化到数据库中，使得对象的数据能够在程序重启后得以保留。

#### ORM 的优势包括：

提高开发效率： ORM 让开发者不必直接编写 SQL 语句，减少了与数据库交互的复杂性，提高了开发效率。
提高可维护性： ORM 使得代码更加清晰和易于理解，降低了程序的耦合度，提高了代码的可维护性。
跨平台兼容性： ORM 提供了对多种数据库的支持，使得应用程序能够在不同的数据库管理系统之间迁移和切换。
### gorm
ORM 是一个 Go 语言的 ORM（Object-Relational Mapping）库，用于简化 Go 语言程序与数据库的交互。
ORM 是一种编程技术，它允许开发者使用面向对象的方式来操作数据库，而不必直接编写 SQL 语句。
GORM 提供了一组方法和结构体，用于定义和操作数据库模型（Model），并提供了对常见数据库操作的支持，包括增删改查（CRUD）、数据迁移、事务处理等功能。
它支持多种主流的关系型数据库，如 MySQL、PostgreSQL、SQLite、SQL Server 等。
#### GORM 主要特点包括：
简洁易用： GORM 提供了简洁的 API 和丰富的文档，使得开发者能够轻松上手，并且提高了代码的可读性和可维护性。
自动迁移： GORM 支持自动迁移功能，能够根据模型定义自动创建、更新数据库表结构，方便开发者进行数据库的版本管理和升级。
链式操作： GORM 的 API 设计采用链式操作的风格，使得开发者可以通过链式调用方法来构建复杂的数据库查询和操作。
事务支持： GORM 提供了事务处理功能，允许开发者对数据库操作进行事务管理，保证数据的一致性和完整性。
Callback： GORM 提供了丰富的回调函数，允许开发者在模型生命周期的各个阶段插入自定义逻辑，实现更灵活的业务处理。
// Delete - 删除 product,并没有执行delete语句，逻辑删除
db.Delete(&product, 1)

#### 逻辑删除：
定义： 逻辑删除是指通过修改数据的状态或添加额外的标记来表示数据已被删除，而实际上并未从数据库中移除。
通常会在表中增加一个表示删除状态的字段，比如一个名为 deleted_at 的时间戳字段，用于标记记录的删除时间。
优点： 逻辑删除保留了数据的历史记录，可以方便地进行数据恢复或者审计，同时避免了数据丢失。
缺点： 需要额外的字段来表示删除状态，可能会增加数据库存储空间的消耗，并且需要在查询数据时考虑过滤已删除的记录。
#### 物理删除：
定义： 物理删除是指直接从数据库中删除数据记录，彻底清除数据，使其不再存在于数据库中。
优点： 释放了数据库存储空间，减少了数据库的存储压力。
缺点： 数据一旦被删除就无法恢复，可能会导致数据丢失，不利于数据审计和追溯。


#### 更新0值

Code       sql.NullString // 商品编码
db.Create(&Product{Code: sql.NullString{"D42", true}, Price: 100})
db.Model(&product).Updates(Product{Price: 200, Code: sql.NullString{"", true}})

#### 模型mode
GORM 通过将 Go 结构体（Go structs） 映射到数据库表来简化数据库交互。 了解如何在GORM中定义模型，是充分利用GORM全部功能的基础。
`type Product struct {
gorm.Model                // GORM 提供的公共模型，包含 ID、CreatedAt、UpdatedAt、DeletedAt 字段
Code       sql.NullString // 商品编码
Price      uint           // 商品价格
}`

##### // gorm.Model 的定义

``type Model struct {
ID        uint           `gorm:"primaryKey"`
CreatedAt time.Time
UpdatedAt time.Time
DeletedAt gorm.DeletedAt `gorm:"index"`
}
``
使用 GORM Migrator 创建表时，不会创建被忽略的字段
update语句可以更新0值，updates语句不可以

#### 解决进更新非零值字段的方法有两种

1.将string设置为*string
2.使用sql的NULxxx来解决

# 第五天

## 第七周

### gin学习

``type Person struct {
ID   int    `uri:"id" binding:"required"`    // ID字段从URI中的id参数获取值，并且是必需的
Name string `uri:"name" binding:"required"`  // Name字段从URI中的name参数获取值，并且是必需的
}
``
`if err := c.ShouldBindUri(&person); err != nil {
// 如果绑定失败，返回404状态码
c.Status(404)
return
}`

// 处理/post请求的处理函数
func getPost(c *gin.Context) {
// 从查询参数中获取"id"
id := c.Query("id")
// 从查询参数中获取"page"，如果没有提供则默认值为"0"
page := c.DefaultQuery("page", "0")
// 从表单参数中获取"name"
name := c.PostForm("name")
// 从表单参数中获取"message"，如果没有提供则默认值为"信息"
message := c.DefaultPostForm("message", "信息")

ShouldBind 是 gin-gonic/gin 框架中用于绑定请求参数到结构体的一个方法。
它会根据请求的 Content-Type 自动选择合适的绑定方式，将请求参数绑定到结构体中。
ShouldBind 系列方法有多个变种（例如 ShouldBindJSON, ShouldBindQuery, ShouldBindForm 等），每种方法适用于不同类型的请求参数。

validator 是一个 Go 语言的包，用于对结构体中的字段进行验证。它是功能强大的验证库，允许开发者使用标签在结构体字段上定义验证规则。
validator 可以用于验证各种数据类型，并且支持自定义验证规则和国际化翻译。

# 第六天
## 用户相关的微服务
密码加密不用对称加密，因为密码不可以反解，所以采用不对称加密。采用md5算法是一个信息摘要算法
密码如果不可反解，如何找回密码。

### MD5
md5一个信息摘要算法，是一种常用的散列函数，用于生成信息摘要或哈希值。其主要功能是将任意长度的输入（如文件或文本）通过一种不可逆的数学转换，
输出为固定长度（通常是128位，即32个十六进制字符）的哈希值。

#### 用途：

数据完整性验证：在数据传输或存储过程中，通过比对MD5哈希值，可以检测数据是否被篡改。
数字签名：结合公钥加密算法，MD5可以用于数字签名，确保消息的完整性和真实性。
密码存储：尽管不推荐，但有时MD5用于存储用户密码的哈希值（应结合盐值来增加安全性）。

#### 特性

压缩性：任意长度的数据算出的MD5值的长度都是固定的。
容易计算：从源数据计算出MD5值很容易
抗修改性：对源数据进行任何修改，哪怕一个字节，MD5值差异很大。
强碰撞：想找两个不同数据，使他们具有相同的MD5值，非常困难
不可逆性，不可反解

### MD5盐值加密

#### 1.加盐

1.通过生成随机数和MD5生成字符串进行组合
2.数据库同时存储MD5值和salt值，验证正确性使用salt进行MD5即可

##### //举例
`
func genMd5(code string) string {
// 创建一个新的MD5哈希对象
Md5 := md5.New()
// 将输入字符串写入到MD5哈希对象中进行处理
// io.WriteString 返回两个值（写入的字节数和错误信息），这里用下划线 "_" 忽略它们
_, _ = io.WriteString(Md5, code)
// 计算输入字符串的MD5哈希值，并将其转换为十六进制字符串后返回
return hex.EncodeToString(Md5.Sum(nil))
}
`
//MD5 彩虹表是一种预计算的哈希值查找表，用于通过反向查找快速破解 MD5 哈希值。为了防止这样的攻击，常见的做法是使用 "盐"（salt）来增强哈希算法的安全性。
fmt.Sprintf("$pbkdf2-sha512$%s$%s", salt, encodedPwd) 这一行代码中，$ 符号的作用是作为分隔符，用于将不同部分的字符串连接起来。
具体来说，这个字符串格式化操作的目的是生成一个符合某种规范的加密密码字符串。

`// DB 定义了一个包含数据库操作相关信息的结构体
type DB struct {
Config       *Config   // 指向数据库配置信息的指针
Error        error     // 表示数据库操作过程中的错误，如果为 nil 则表示操作成功
RowsAffected int64     // 表示数据库操作影响的行数，如插入、更新、删除操作影响的行数
Statement    *Statement // 指向数据库语句的指针，用于执行特定的 SQL 语句或事务操作
clone        int       // 克隆次数或其他用途的整数字段，具体用途需要根据上下文进一步确认
}`
第八周over

## 学习总结:

今天实现了用户的grpc服务，首先将数据库的数据库连接初始化和管理代码放在一个独立的包global里面，

### 为什么要放在一个包里面？
全局可访问性和单例模式：通过将数据库连接对象 DB 定义为包级别的变量，可以确保在整个应用程序中只有一个数据库连接实例。
这种单例模式有助于避免在多个地方重复创建连接，确保数据库资源的有效利用和一致性管理。
解耦和模块化：将数据库连接代码独立为一个包，有助于将数据库操作与业务逻辑分离
统一的初始化和配置：在包的 init() 函数中进行数据库连接的初始化，可以确保在应用程序启动时就完成数据库的连接和配置。
这种方式能够集中处理数据库的连接参数、日志记录设置等，使得管理和调整数据库配置变得更加方便。
跨包访问：定义全局的数据库连接对象允许其他包或模块可以轻松地访问数据库服务。
这对于大型应用程序或者微服务架构尤为重要，不同的服务或模块可以共享同一个数据库连接实例，实现数据的一致性和统一管理。

随后定义了protobuf,定义了用户的常见服务
`service User {
// 定义 User 服务
rpc GetUserList(PageInfo) returns (UserListResponse); // 获取用户列表
rpc GetUserByMobile(MobileRequest) returns (UserInfoResponse); // 通过手机号查询用户
rpc GetUserById(IdRequest) returns (UserInfoResponse); // 通过 ID 查询用户
rpc CreateUser(CreateUserInfo) returns (UserInfoResponse); // 添加用户
rpc UpdateUser(UpdateUserInfo) returns (google.protobuf.Empty); // 更新用户
rpc CheckPassWord(PasswordCheckInfo) returns (CheckResponse); // 检查密码
}`
学习了 MD5盐值加密

### 随后建立了一个hander包
主要是实现了用户的处理函数
实现了ModelToRsponse 用于将数据库中的用户模型转换为 gRPC 的用户响应消息
数据库中的用户模型转换为 gRPC 的用户响应消息是为了适配不同层次的需求，并确保在不同系统组件之间传递数据时的一致性和安全性
实现了分页函数
Paginate 函数的作用是为了将分页逻辑封装在一个可复用的函数中，以便在数据库查询中轻松设置和应用分页参数，提高代码的复用性、灵活性和可维护性。
实现user服务的函数

### 定义了一个model包
这段代码定义了一个名为 model 的包，主要用于定义应用程序中的数据模型，特别是用户数据模型 User 和基础模型 BaseModel
是一个基模，代表用户的信息

# 第七天第九周
config文件用来存放一些配置信息，forms用来做表单验证，global全局的变量，initialize初始化配置，middlewares中间件
router存放路由，validator验证规则
go日志库zap

## 路由的作用和定义

### 定义

路由是指确定数据包从源设备到达目的设备所经过的路径。
路由器根据路由表中的信息，决定如何将数据包从一个网络接口转发到另一个网络接口，以便数据包能够到达最终目的地。

### 作用
路由的主要作用是确保数据能够在网络中高效且可靠地传输，避免网络拥塞和数据丢失，同时尽可能地减少传输延迟。

### 路由的类型
静态路由（Static Routing）：
静态路由是由网络管理员手动配置的固定路由路径。静态路由简单、易于管理，但在网络拓扑发生变化时需要手动更新。
动态路由（Dynamic Routing）：
动态路由使用路由协议自动计算和更新路由表。常见的动态路由协议包括RIP（Routing Information Protocol）、OSPF（Open Shortest Path First）
和BGP（Border Gateway Protocol）。动态路由可以根据网络状态的变化自动调整路径，适应性强。

## 什么是日志库
日志库是指在软件开发中用于记录和管理应用程序运行期间生成的日志信息的工具或库。日志信息可以包括错误消息、调试信息、警告、操作记录、性能指标等。
通过日志库，开发人员可以方便地记录和查询这些信息，以便调试、监控和维护应用程序。

zap.S() 是 zap 日志库中的一个全局函数，用于返回全局的 SugaredLogger 实例
全局 logger 替换为自定义的 logger，可以确保你的应用程序中所有的日志记录操作都使用同一个 logger 实例
zap.ReplaceGlobals(logger)

## go的配置文件管理-yaml
### 定义
配置文件（Configuration file）是一种用于存储应用程序配置参数的文件。它通常是一个文本文件，包含了应用程序在运行时需要的各种设置、选项和参数。
配置文件的主要作用是使得应用程序在不同环境中的部署和运行可以通过修改配置文件而不需要修改源代码或重新编译实现。

### yaml
YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，用于表示数据结构和配置信息。
它设计简洁、易读、易写，适合作为配置文件、数据传输协议和存储格式使用。

#### 主要特点：
易读性：
YAML 使用空格缩进和换行来表示数据结构，使得文件结构清晰、易读。
易写性：
YAML 使用简洁的语法，避免了大量的符号和标记，减少了人为错误的可能性。
数据结构：
支持多种数据结构，包括映射（键值对）、序列（数组列表）、标量（字符串、数值等）。
可扩展性：
支持注释和包含（include）等功能，增强了配置文件的灵活性和可用性。
跨语言支持：
YAML 是一种语言无关的格式，多种编程语言都有相应的解析库和工具支持。

## Cookie 和 Session ID
用于在客户端（浏览器）和服务器之间维护状态和识别用户身份的重要工具：

### Cookie：

#### 定义：
Cookie 是存储在用户计算机上的小型文本文件，由服务器在 HTTP 协议中发送给客户端（浏览器），并保存在客户端的本地文件中。

#### 作用
主要用于跟踪和识别用户，实现用户和网站之间的持久状态管理。例如，保持用户登录状态、记录用户的偏好设置等。

#### 特点：

持久性：可以设置过期时间，使得信息可以长期存储在客户端。
大小限制：每个 Cookie 的大小通常限制在几 KB 到几 MB 之间。
安全性：可以通过设置 HttpOnly、Secure 和 SameSite 等属性来增强安全性，防止恶意攻击。

## Session ID：

### 定义：
Session ID 是在用户与服务器建立会话时生成的唯一标识符。通常存储在服务器端，用于标识和区分不同的用户会话。

### 作用：
用于在多个请求之间维护用户的状态和会话信息。与 Cookie 结合使用，通常是通过 Cookie 存储 Session ID，并通过 Session ID 在服务器端查找和恢复用户的会话信息。

### 特点：

唯一性：每个 Session ID 在一个时间段内应该是唯一的。

时效性：通常随着会话的结束或过期而失效，可以设置过期时间来管理会话的有效期限。

## Cookie 和 Session ID 的关系：

典型的 Web 应用场景中，服务器会在用户登录成功后生成一个 Session ID，并将其存储在 Cookie 中发送给客户端，客户端浏览器在之后的请求中会带上这个 Cookie。
服务器根据 Cookie 中的 Session ID 来查找和恢复用户的会话状态，从而实现保持用户登录状态、跟踪用户操作等功能。

## json web token
JSON Web Token（JWT）是一种开放标准（RFC 7519），定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。
JWT 主要用于在网络应用和服务之间传递声明（claims），以便于身份验证和信息交换。

### 结构和组成

一个 JWT 由三部分组成，这三部分使用点号（.）分隔，分别是：

Header（头部）：包含了两部分信息，声明类型（typ）和使用的加密算法（alg），通常是 Base64 编码后的 JSON 对象。
Payload（负载）：也称为 Claims（声明），包含了需要传输的信息，例如用户的身份信息、权限等，也是 Base64 编码后的 JSON 对象。
Signature（签名）：由头部、负载和一个秘密（或公钥）进行加密生成，用于验证消息在传输过程中没有被篡改。

### 用途

JWT 主要用于在用户和服务器之间安全地传递声明（claims），最常见的用途包括：

认证（Authentication）：JWT 可以作为用户认证的一种方式，用户登录成功后，服务器生成 JWT 并将其返回给客户端。客户端在接下来的请求中通过在请求头或参数中携带 JWT 来验证身份。

信息交换（Information Exchange）：由于 JWT 包含了负载信息，可以在各方之间安全地传输数据。例如，在微服务架构中，可以使用 JWT 在服务之间传递用户信息和权限信息，而无需每次请求都查询数据库。

状态管理（Stateless Sessions）：由于 JWT 包含了足够的信息，服务器不需要在自己的存储中保存会话信息，从而使服务端变得无状态（stateless），这样有助于水平扩展和负载均衡。
### 优点
自包含（Self-contained）：JWT 包含了所有用户必要的信息，减少了服务器查询数据库的需求。
跨语言和平台（Cross-language and Cross-platform）：JWT 是基于 JSON 格式的标准化协议，易于在不同的系统中传递和解析。
安全性（Security）：JWT 可以使用签名（HMAC 算法或公钥/私钥对）来验证发送者的身份和保证消息的完整性，防止数据篡改。
看至 2-9
# 第八天
## 第九周over
## 主函数
初始化日志，配置文件，路由，以及翻译器，注册验证器，启动gin服务。
### 如何初始化日志：
首先创建一个新的生产环境的 logger 实例logger, _ := zap.NewProduction()
#### 为什么使用zap?
zap 是一个高性能的、结构化的日志库，专为速度和低内存使用而设计.

然后全局logger 替换为自定义的 logger，可以确保你的应用程序中所有的日志记录操作都使用同一个 logger 实例zap.ReplaceGlobals(logger)

### 为什么要使用同一个logger实例

#### 一致的日志格式和风格：
使用同一个 logger 实例可以确保整个应用程序的日志输出具有统一的格式、风格和标准，这有助于提高日志的可读性和易用性。
开发人员和运维团队在查看日志时不需要适应不同的输出方式，减少了理解和分析日志的难度。

#### 性能优化：
一些日志库在初始化时可能会进行一些预处理或者资源分配，例如打开文件、建立连接等。如果在整个应用程序中重复创建不同的 logger 实例，
可能会增加不必要的开销和资源消耗。而使用同一个 logger 实例可以避免这种开销，提高应用程序的性能和效率。

#### 便于集中管理和配置：
使用同一个 logger 实例可以更方便地进行集中管理和配置。例如，可以在应用程序的某个地方统一配置日志级别、输出格式、日志文件路径等，
而不是在多个地方分散配置。这样做不仅简化了维护工作，还能确保配置的一致性和正确性。

#### 简化日志记录代码：
全局使用同一个 logger 实例可以简化日志记录代码。开发人员无需在每个日志记录点重复创建 logger 实例或者传递 logger 实例作为参数， 而是直接使用全局的 logger 实例即可。

#### 日志追踪和审计：
如果应用程序需要实现日志的追踪、审计或者日志分析，使用同一个 logger 实例可以更方便地跟踪和关联不同事件的日志记录，从而实现更精确和细致的日志分析和监控。

## 初始化配置文件

### 什么是配置文件

配置文件是一种用于存储应用程序配置信息的文件，通常采用特定的格式或语法编写，以便应用程序可以读取和解析其中的配置参数。
配置文件的作用是为了方便应用程序在不同环境中进行配置和调整，使得应用程序在部署和运行过程中具有灵活性和可配置性

### 过程
首先通过 viper.AutomaticEnv()自动从环境变量中读取配置信息，然后viper.GetBool(env) 获取布尔类型的环境变量值，通过v := viper.New()设置一个新的
viper 实例，v.SetConfigFile(configFileName)设置配置文件路径。然后解析配置文件并把信息存储在全局变量里面。分别提取服务器配置和客户端配置信息到相应局部变量。然后创建配置客户端。

### 为什么将配置信息存储在全局变量中？

的主要原因是为了方便应用程序在各个模块和组件之间访问和使用这些配置信息。全局变量可以在应用程序的任何地方被访问到，
避免了在每个需要使用配置信息的地方都重新加载和解析配置文件，从而提高了代码的简洁性和可维护性。

### 初始化路由
首先 创建一个默认的 Gin 引擎实例，包含默认的中间件（日志记录和恢复） Router := gin.Default()，然后定义一个健康检查端点，用于验证服务是否运行。
使用 CORS 中间件处理跨源资源共享，Router.Use(middlewares.Cors())。创建一个 API 分组，基础路径为 "/u/v1"。 ApiGroup := Router.Group("/u/v1")
在 API 分组中初始化与用户相关的路由，router2.InitUserRouter(ApiGroup)。在 API 分组中初始化基础路由，router2.InitBaseRouter(ApiGroup)。
返回配置好的 Gin 引擎实例，Router。

## 初始化翻译
修改gin框架中的validator引擎属性，实现定制，直接去网上找到现成的代码。

## 注册验证器
获取当前的验证引擎实例binding.Validator.Engine().(*validator.Validate);自定义的手机号验证函数 ValidateMobile 注册到引擎中
_ = v.RegisterValidation("mobile", myvalidator.ValidateMobile)
注册手机号验证的错误信息翻译，_ = v.RegisterTranslation("mobile", global.Trans,

添加手机号验证错误的翻译信息到翻译器中在这个过程中使用到了第三方库
github.com/go-playground/universal-translator 是一个 Go 语言库，用于支持多语言翻译和本地化的工具。
它提供了一种统一的方式来处理文本翻译和国际化，使得开发者可以轻松地在应用程序中实现多语言支持。
func(ut ut.Translator) error {
return ut.Add("mobile", "{0} 非法的手机号码!", true)
},

定义翻译器如何生成具体的错误消息，fe.Field() 获取错误字段的名称
func(ut ut.Translator, fe validator.FieldError) string {
t, _ := ut.T("mobile", fe.Field())
return t
})

## 第十周

## 服务注册与发现
### 服务注册
每个服务实例在启动时，将自己的位置信息（如IP地址和端口）注册到一个服务注册中心。服务注册中心会记录这些信息，并定期进行健康检查，以确保服务的可用性。
### 服务发现
当一个服务或客户端需要调用另一个服务时，会通过服务注册中心查询所需服务的位置信息，从而进行调用。服务发现有两种模式：
客户端发现：客户端直接查询服务注册中心，获取服务地址并调用。
服务端发现：客户端通过负载均衡器发送请求，负载均衡器负责查询服务注册中心，并将请求转发给具体的服务实例。

## consul
Consul 是一个用于实现微服务架构的服务发现和配置管理工具，它提供了一系列功能，帮助开发者和运维人员管理和维护分布式系统

### 服务发现（Service Discovery）：

Consul 允许服务在启动时自动注册自己，并通过 DNS 或 HTTP 进行查找。这使得服务能够动态发现和连接到其他服务，而不需要硬编码服务位置。

### 健康检查（Health Checking）：

Consul 提供健康检查功能，可以持续监控服务的健康状态。如果某个服务不可用或运行不正常，Consul 会从服务发现列表中移除它。

### 键值存储（Key/Value Store）：

Consul 提供了一个简单的分布式键值存储，适用于配置管理和协调。

### 多数据中心支持（Multi-Datacenter Support）：

Consul 可以跨多个数据中心工作，这对于高可用性和灾难恢复非常重要。

### 服务网格（Service Mesh）：

Consul 提供服务网格功能，通过内置的代理（Consul Connect）实现服务间安全通信、负载均衡和观察能力。

# 第九天
## 负载均衡
### 集中式负载均衡
集中式负载均衡是一种有效的负载均衡方法，通过统一管理和控制请求分发，优化资源使用和系统性能。选择合适的负载均衡策略和配置高可用性机制，可以构建高效、可靠的系统架构。
### 进程内负载均衡
进程内负载均衡（In-Process Load Balancing）是一种在单个进程内部进行请求分发和负载均衡的方法。
它通常用于微服务架构或客户端应用程序中，由客户端库或服务框架负责在多个服务实例之间分发请求。
#### 进程内负载均衡的特点

#### 低延迟：
由于负载均衡发生在进程内部，不涉及网络传输，因此具有较低的延迟。

#### 简化架构：
不需要单独的负载均衡器，减少了系统复杂性和潜在的单点故障。

#### 灵活性：
可以根据应用需求实现各种自定义负载均衡策略。

#### 典型应用场景
微服务客户端：微服务的客户端库实现进程内负载均衡，将请求分发到多个微服务实例。
客户端应用程序：客户端应用程序内嵌的负载均衡库分发请求到多个后端服务。
轻量级服务框架：在轻量级服务框架中，通过进程内负载均衡分发请求。
### 独立进程负载均衡
独立进程负载均衡（Standalone Load Balancer）是一种将负载均衡功能从应用服务器中分离出来，独立运行的进程或服务。
这种负载均衡器在客户端请求与后端服务器之间起中介作用，负责将请求按照一定策略分发到多个后端服务器。独立进程负载均衡器通常部署在应用服务器之前，作为所有请求的统一入口。

#### 独立进程负载均衡的主要特征

统一管理：所有请求通过独立的负载均衡器处理，实现统一的负载均衡策略和流量控制。
灵活配置：独立进程负载均衡器可以灵活配置和调整，支持多种负载均衡算法和健康检查机制。
高可用性：可以通过集群部署和故障转移机制实现高可用性，避免单点故障
## 负载均衡的算法

### 轮询（Round Robin）
原理：按顺序将请求依次分配给每个服务器，循环往复。
优点：
简单易实现。
适用于服务器性能相似的情况。
缺点：
未考虑服务器的负载情况，可能导致不均衡。

### 加权轮询（Weighted Round Robin）
原理：为每个服务器分配一个权重，权重高的服务器分配到的请求更多。
优点：
适用于服务器性能不一致的情况。
缺点：
权重配置需要根据服务器性能进行调整。

### IP 哈希（IP Hash）

原理：根据客户端 IP 地址的哈希值分配服务器，确保同一客户端总是连接到同一台服务器。
优点： 保证一客户端会话的一致性。 适用于需要会话保持的应用。
缺点 可能导致部分服务器过载。

### 随机（Random）
原理：随机选择一台服务器分配请求。
优点： 实现简单。
能在一定程度上均衡负载。

### 一致性哈希（Consistent Hashing）

原理：使用一致性哈希算法分配请求，适用于分布式缓存场景，减少服务器变更时的数据迁移。
优点： 减少数据重新分布，适用于缓存服务器。 适用于需要高一致性的场景。
缺点： 实现复杂度高。

### 加权最少连接数（Weighted Least Connections）
原理：在最少连接数算法的基础上，考虑服务器的权重。
优点： 结合了加权轮询和最少连接数的优点。 动态分配请求，适应服务器性能差异。
缺点：要实时维护每个服务器的连接数和权重。

### 最少连接数（Least Connections）
原理：将请求分配给当前连接数最少的服务器。
优点： 动态分配请求，均衡负载。 适用于长连接场景。
缺点： 需要实时维护每个服务器的连接数。

## 配置中心

### Nacos
是一个开源的动态服务发现、配置管理和服务管理平台，主要用于微服务架构。它由阿里巴巴开源，能够帮助开发者更好地构建、管理和维护分布式系统。
服务发现和健康检查：

Nacos 支持服务的动态注册和发现。服务可以在启动时向 Nacos 注册自己的信息，其他服务可以通过 Nacos 查询来发现需要连接的服务。
提供健康检查机制，确保服务的可用性。如果服务不可用，Nacos 会自动将其从注册列表中移除。
动态配置管理：
Nacos 提供集中化的配置管理，支持配置的动态更新和推送。配置可以在运行时进行更改，无需重启服务。
支持各种配置格式，如 YAML、Properties 等，能够方便地管理不同环境下的配置。
服务管理：
提供服务元数据管理、服务路由和服务流量管理等功能。
支持多种负载均衡策略，如随机、轮询、权重等。
Nacos 提供多语言客户端支持，方便不同技术栈的服务使用 Nacos 提供的功能。

使用场景
微服务架构：
在微服务架构中，Nacos 可以作为服务发现和配置管理的中心，简化服务的管理和配置更新。
分布式系统：
在大规模分布式系统中，Nacos 可以帮助管理和监控服务的健康状态，提供高可用和可靠的服务发现机制。
配置管理：
提供集中化的配置管理平台，方便对多个环境下的配置进行管理和动态更新